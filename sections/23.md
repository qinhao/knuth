## [23 - Learning about the Symbolic Optimum Assembly Program and the Internal Translator (Part 1)](http://webofstories.com/play/17082)

My family went to a summer camp in, on the shore of Lake Erie for a
week, that summer, and, Linwood, it’s called. I revisited it a couple
of years ago, to remember. Anyway, it’s on the beach, two weeks we
were there, and I would play tennis with my uncles and so on, but I
also **had brought with me the, a couple of examples of computer
programs that I had heard about**, and so I had some spare time while
I’m at the summer place, to look at these programs. And this made a
big influence on my future life, actually.

One of the programs was
what they call an assembler, which was, meant that instead of writing
in the machine language, you could write in a more symbolic language
that would make it easier for, I mean I, when I started my programming
**I was just programming everything in numbers**. And so, if I wanted to
add, add a number in location one to the number in location two, I
would have to say something like, 20, oh, oh, one, something, anyway,
I would have to **write all these numbers out, and punch them into
cards**, and get it to work, and this was all I knew, when I started
programming.

But then the symbolic, the assembly program was a
new-fangled thing at the time, and allowed me to do it in a way that’s
more easier to understand. **Instead of choosing a number for every
place in my program, I could give it a name**, and then the machine
would figure out the, you know, what number to associate with that
name. And in those days computers couldn’t deal with letters very
well, the computers were more set up for numbers, but we were allowed
to use capital letters, so we had, so, and in this assembler we could
use five capital letters, for a word, and I remember specifically when
I used this for my tic-tac-toe program, and I, and I would have to
think, what five-letter word would I use to indicate a current part of
the program, and I remember, you know, with delight, when I want in my
tic-tac-toe program, when it wins, I would go to location BINGO. So I
could use the five-letter word B, I, N, G, O, for that part of the
program.

Okay, so I’m learning about a symbolic assembler at this
time, and so I got the code, all right? So I’m using the assembler,
but **I was wondering how it did it**? How did you know, how, what went
on, behind the scenes that would take my symbolic thing that said,
BINGO, and put it into numbers that the machine would understand
directly? And so I had the listing for this program called SOAP Two,
by Stan Poley of IBM.

Then I had also brought with me another listing,
from a program called IT, or Internal Translator, and this was a new
program; had come from Carnegie Tech, later Carnegie Mellon
University, written by four people at Carnegie, and IT took **an
algebraic language**, instead of a machine language. So you’re writing
here; it’s a; this is early days, this was before FORTRAN or other
high-level languages were known. I’m talking here of 1956, 1957. The
idea here then, you can write X = A + B. Ah, well, **you couldn’t really
write that because we didn’t have plus signs**, so we would really
write, X one, Z, X two, S, X three, where S stood for plus, and Z
stood for equals, and, you know, and every variable was X one, X two,
X three or something like this, but anyway, you could put in algebraic
formula on your card, and then the machine would figure out, from
that, how to compute A + B and store it in X, or whatever you wanted
it to do.

So instead of a numeric thing; instead of a symbolic version
of a numeric thing, it was algebraic, and you would put your program
from the IT language into the computer, and it would flash the lights
for a while, and then, punch, punch, punch, punch, and give you a
machine language, in the computer’s language. Magic. I couldn’t; **I
hadn’t a clue as to how this was possible** at all, so I got a copy of
the program that they had used, to write this IT, translator, and I
had a copy of the SOAP program, the Symbolic Assembly, the Symbolic
Optimum Assembly Program.)

